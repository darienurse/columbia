Matthew Patey mep2167
Darien Nurse don2102
Hashmap

Our initial strategy was to implement a lock free data structure. We used a 2d array of dimensions Nx2, where N is number of buckets, thus (i,0) was the key at index i and (i,1) was the value. The array was initialized with atomic longs set to min_value to represent empty. For a given index (starting at key mod array size), If the bin is empty, then CAS is used to attempt to set the key slot to the given key. If this is successful, then the bucket has been claimed by the current task, and the value set with repeated CAS until success (only failure of this CAS would occur if another thread is updating same key, so order here is arbitrary). If the CAS fails or the key slot is not null, linear probing is used until setting the key is successful. A key slot matching the current key is treated the same as finding an empty bucket, except that it skips setting the key.

Unfortunately, though the data structure had a linearization point of the CAS used to set the value, there was no lock free way to also update the linearization counter across this same linearization point, so the HM had to be modified. We still find the appropriate bucket in the same way, but instead of using a CAS to set the value, a lock is obtained, and in its critical region the value is set and the counter incremented. Additionally, in get a lock is obtained before reading the value and incrementing the counter. Because an atomic operation in a locked region is redundant, the value was changed to a Cell[Long]. This required the the 2d array to be replaced by a Rail[Pair[AtomicLong, Cell[Long]]. Using the lock approximately doubled our average runtime.
